C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 1   


C51 COMPILER 6.01, COMPILATION OF MODULE SPI
OBJECT MODULE PLACED IN .\spi.OBJ
COMPILER INVOKED BY: H:\Keil\C51\BIN\C51.EXE .\spi.c DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS

stmt level    source

   1          /*****************************************************************************
   2          spi.c 4-19-00 ott
   3          Used to test software spi functionality on EZ-USB
   4          This program will do a constant write and readback loop to an
   5          25C320 spi EEPROM with EZ-USB as the master
   6          Pins used:
   7          C0 - Chip select
   8          C1 - Clk
   9          C2 - MOSI Data OUT from EZ
  10          C3 - MISO Data In to EZ
  11          This pins can be changed if you change the bitmasks defines here and in
  12          spiwrite.a51 and spiread.a51
  13          *****************************************************************************/
  14          
  15          #include <ezusb.h>
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //	File:		ezusb.h
   3      =1  //	Contents:	EZ-USB constants, macros, datatypes, globals, and library
   4      =1  //				function prototypes.
   5      =1  //
   6      =1  //	Copyright (c) 1997 AnchorChips, Inc. All rights reserved
   7      =1  //-----------------------------------------------------------------------------
   8      =1  #ifndef EZUSB_H		//Header sentry
   9      =1  #define EZUSB_H
  10      =1  
  11      =1  //#define CHIPREV_B					// Indicate target chip revision
  12      =1  #define CHIPREV_C
  13      =1  
  14      =1  #define GET_CHIP_REV()		((CPUCS >> 4) & 0x00FF) // EzUSB Chip Rev Field
  15      =1  //#define EZUSB_CHIPREV_B 0		// This Rev has been taken over by TNG
  16      =1  #define EZUSB_TNG_CHIPREV_A 0	// Rev 0 now means TNG RevA
  17      =1  #define EZUSB_CHIPREV_C 2
  18      =1  #define EZUSB_CHIPREV_D 3
  19      =1  #define EZUSB_CHIPREV_E 4
  20      =1  
  21      =1  #define INTERNAL_DSCR_ADDR 0x0080	// Relocate Descriptors to 0x80
  22      =1  #define bmSTRETCH 0x07
  23      =1  #define FW_STRETCH_VALUE 0x0		// Set stretch to 0 in frameworks
  24      =1  									// Note: a RevE eratta states that stretch must=0 to set OUTxBC
  25      =1  
  26      =1  //-----------------------------------------------------------------------------
  27      =1  // Constants
  28      =1  //-----------------------------------------------------------------------------
  29      =1  #define	TRUE 	1
  30      =1  #define FALSE	0
  31      =1  
  32      =1  #define bmBIT0	0x01
  33      =1  #define bmBIT1	0x02
  34      =1  #define bmBIT2	0x04
  35      =1  #define bmBIT3	0x08
  36      =1  #define bmBIT4	0x10
  37      =1  #define bmBIT5	0x20
  38      =1  #define bmBIT6	0x40
  39      =1  #define bmBIT7	0x80
  40      =1  
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 2   

  41      =1  #define DEVICE_DSCR		0x01		// Descriptor type: Device
  42      =1  #define CONFIG_DSCR		0x02		// Descriptor type: Configuration
  43      =1  #define STRING_DSCR		0x03		// Descriptor type: String
  44      =1  #define INTRFC_DSCR		0x04		// Descriptor type: Interface
  45      =1  #define ENDPNT_DSCR		0x05		// Descriptor type: End Point
  46      =1  
  47      =1  #define	bmBUSPWR	bmBIT7			// Config. attribute: Bus powered
  48      =1  #define bmSELFPWR	bmBIT6			// Config. attribute: Self powered
  49      =1  #define bmRWU		bmBIT5			// Config. attribute: Remote Wakeup
  50      =1  
  51      =1  #define bmEPOUT		bmBIT7
  52      =1  #define bmEPIN		0x00
  53      =1  
  54      =1  #define EP_CONTROL	0x00			// End Point type: Control
  55      =1  #define EP_ISO		0x01			// End Point type: Isochronous
  56      =1  #define EP_BULK		0x02			// End Point type: Bulk
  57      =1  #define EP_INT		0x03			// End Point type: Interrupt
  58      =1  
  59      =1  #define SUD_SIZE				8		// Setup data packet size
  60      =1  
  61      =1  //////////////////////////////////////////////////////////////////////////////
  62      =1  //Added for HID
  63      =1  
  64      =1  #define SETUP_MASK				0x60	//Used to mask off request type
  65      =1  #define SETUP_STANDARD_REQUEST	0		//Standard Request
  66      =1  #define SETUP_CLASS_REQUEST		0x20	//Class Request
  67      =1  #define SETUP_VENDOR_REQUEST	0x40	//Vendor Request
  68      =1  #define SETUP_RESERVED_REQUEST 	0x60	//Reserved or illegal request
  69      =1  
  70      =1  //////////////////////////////////////////////////////////////////////////////
  71      =1  
  72      =1  
  73      =1  #define SC_GET_STATUS			0x00	// Setup command: Get Status
  74      =1  #define SC_CLEAR_FEATURE		0x01	// Setup command: Clear Feature
  75      =1  #define SC_RESERVED				0x02	// Setup command: Reserved
  76      =1  #define SC_SET_FEATURE			0x03	// Setup command: Set Feature
  77      =1  #define SC_SET_ADDRESS			0x05	// Setup command: Set Address
  78      =1  #define SC_GET_DESCRIPTOR		0x06	// Setup command: Get Descriptor
  79      =1  #define SC_SET_DESCRIPTOR		0x07	// Setup command: Set Descriptor
  80      =1  #define SC_GET_CONFIGURATION	0x08	// Setup command: Get Configuration
  81      =1  #define SC_SET_CONFIGURATION	0x09	// Setup command: Set Configuration
  82      =1  #define SC_GET_INTERFACE		0x0a	// Setup command: Get Interface
  83      =1  #define SC_SET_INTERFACE		0x0b	// Setup command: Set Interface
  84      =1  #define SC_SYNC_FRAME			0x0c	// Setup command: Sync Frame
  85      =1  #define SC_ANCHOR_LOAD			0xa0	// Setup command: Anchor load
  86      =1  	
  87      =1  #define GD_DEVICE				0x01	// Get device descriptor: Device
  88      =1  #define GD_CONFIGURATION		0x02	// Get device descriptor: Configuration
  89      =1  #define GD_STRING				0x03	// Get device descriptor: String
  90      =1  #define GD_HID	            0x21	// Get descriptor: HID
  91      =1  #define GD_REPORT	         0x22	// Get descriptor: Report
  92      =1  
  93      =1  #define GS_DEVICE				0x80	// Get Status: Device
  94      =1  #define GS_INTERFACE			0x81	// Get Status: Interface
  95      =1  #define GS_ENDPOINT				0x82	// Get Status: End Point
  96      =1  
  97      =1  #define FT_DEVICE				0x00	// Feature: Device
  98      =1  #define FT_ENDPOINT				0x02	// Feature: End Point
  99      =1  
 100      =1  #define I2C_IDLE				0		// I2C Status: Idle mode
 101      =1  #define I2C_SENDING				1		// I2C Status: I2C is sending data
 102      =1  #define I2C_RECEIVING			2		// I2C Status: I2C is receiving data
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 3   

 103      =1  #define I2C_PRIME				3		// I2C Status: I2C is receiving the first byte of a string
 104      =1  #define I2C_STOP				5		// I2C Status: I2C waiting for stop completion
 105      =1  #define I2C_BERROR				6		// I2C Status: I2C error; Bit Error
 106      =1  #define I2C_NACK				7		// I2C Status: I2C error; No Acknowledge
 107      =1  #define I2C_OK					8		// I2C positive return code
 108      =1  #define I2C_WAITSTOP					9		// I2C Status: Wait for STOP complete
 109      =1  
 110      =1  /*-----------------------------------------------------------------------------
 111      =1  	Macros
 112      =1  -----------------------------------------------------------------------------*/
 113      =1  
 114      =1  #define MSB(word)		(BYTE)(((WORD)(word) >> 8) & 0xff)
 115      =1  #define LSB(word)		(BYTE)((WORD)(word) & 0xff)
 116      =1  
 117      =1  #define SWAP_ENDIAN(word)	((BYTE*)&word)[0] ^= ((BYTE*)&word)[1];\
 118      =1  							((BYTE*)&word)[1] ^= ((BYTE*)&word)[0];\
 119      =1  							((BYTE*)&word)[0] ^= ((BYTE*)&word)[1]
 120      =1  
 121      =1  #define EZUSB_IRQ_ENABLE()	EUSB = 1
 122      =1  #define EZUSB_IRQ_DISABLE()	EUSB = 0
 123      =1  #ifndef CHIPREV_B
 124      =1  #define EZUSB_IRQ_CLEAR()	EXIF &= ~0x10		// IE2_
 125      =1  #endif
 126      =1  
 127      =1  #define EZUSB_STALL_EP0()				EP0CS |= bmEPSTALL
 128      =1  #define EZUSB_STALL_EP(ep_id)  			EPIO[ep_id].cntrl = bmEPSTALL
 129      =1  #define EZUSB_UNSTALL_EP(ep_id)			EPIO[ep_id].cntrl = 0
 130      =1  #define	EZUSB_GET_EP_STATUS(ep_id)		EPIO[ep_id].cntrl
 131      =1  #define EZUSB_SET_EP_BYTES(ep_id,count)	EPIO[ep_id].bytes = count
 132      =1  
 133      =1  // the WRITEDELAY macro compiles to the time equivalent of 3 NOPs.
 134      =1  // It is used in the frameworks to allow for write recovery time
 135      =1  // requirements of certain registers.  This is only necessary for
 136      =1  // EZ-USB FX parts.  See the EZ-USB FX TRM register chapter for
 137      =1  // more information on write recovery time issues.  (Look for "latency applies")
 138      =1  #define WRITEDELAY() {char writedelaydummy = 0;}
 139      =1  // if this firmware will never run on an EZ-USB FX part replace
 140      =1  // with:
 141      =1  // #define WRITEDELAY()
 142      =1  
 143      =1  #define EZUSB_RESET_DATA_TOGGLE(ep)     TOGCTL = (((ep & 0x80) >> 3) + (ep & 0x07));\
 144      =1                                          WRITEDELAY();\
 145      =1                                          TOGCTL |= 0x20
 146      =1  
 147      =1  
 148      =1  #define EZUSB_ENABLE_RSMIRQ()		(EICON |= 0x20)		// Enable Resume Interrupt (EPFI_)
 149      =1  #define EZUSB_DISABLE_RSMIRQ()		(EICON &= ~0x20)	// Disable Resume Interrupt (EPFI_)
 150      =1  #define EZUSB_CLEAR_RSMIRQ()		(EICON &= ~0x10)	// Clear Resume Interrupt Flag (PFI_)
 151      =1  
 152      =1  #define EZUSB_GETI2CSTATUS()		(I2CPckt.status)
 153      =1  #define EZUSB_CLEARI2CSTATUS()		if((I2CPckt.status == I2C_BERROR) || (I2CPckt.status == I2C_NACK))\
 154      =1  										I2CPckt.status = I2C_IDLE;
 155      =1  
 156      =1  #define EZUSB_ENABLEBP()			(USBBAV |= bmBPEN)
 157      =1  #define EZUSB_DISABLEBP()			(USBBAV &= ~bmBPEN)
 158      =1  #define EZUSB_CLEARBP()				(USBBAV |= bmBREAK)
 159      =1  #define EZUSB_BP(addr)				BPADDR = (WORD)addr
 160      =1  
 161      =1  #define EZUSB_EXTWAKEUP()			(USBCS & bmRWAKEUP)
 162      =1  
 163      =1  //-----------------------------------------------------------------------------
 164      =1  // Datatypes
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 4   

 165      =1  //-----------------------------------------------------------------------------
 166      =1  typedef unsigned char	BYTE;
 167      =1  typedef unsigned short	WORD;
 168      =1  typedef unsigned long	DWORD;
 169      =1  typedef bit				BOOL;
 170      =1  
 171      =1  #define	INT0_VECT	0
 172      =1  #define	TMR0_VECT	1
 173      =1  #define	INT1_VECT	2
 174      =1  #define	TMR1_VECT	3
 175      =1  #define	COM0_VECT	4
 176      =1  #define	TMR2_VECT	5
 177      =1  #define	WKUP_VECT	6
 178      =1  #define	COM1_VECT	7
 179      =1  #define	USB_VECT	8
 180      =1  #define	I2C_VECT	9
 181      =1  #define	INT4_VECT	10
 182      =1  #define	INT5_VECT	11
 183      =1  #define	INT6_VECT	12
 184      =1  
 185      =1  #define	SUDAV_USBVECT	(0 << 2)
 186      =1  #define	SOF_USBVECT		(1 << 2)
 187      =1  #define	SUTOK_USBVECT	(2 << 2)
 188      =1  #define	SUSP_USBVECT	(3 << 2)
 189      =1  #define	URES_USBVECT	(4 << 2)
 190      =1  #define	SPARE_USBVECT	(5 << 2)
 191      =1  #define	IN0BUF_USBVECT	(6 << 2)
 192      =1  #define	OUT0BUF_USBVECT	(7 << 2)
 193      =1  #define	IN1BUF_USBVECT	(8 << 2)
 194      =1  #define	OUT1BUF_USBVECT	(9 << 2)
 195      =1  #define	IN2BUF_USBVECT	(10 << 2)
 196      =1  #define	OUT2BUF_USBVECT	(11 << 2)
 197      =1  #define	IN3BUF_USBVECT	(12 << 2)
 198      =1  #define	OUT3BUF_USBVECT	(13 << 2)
 199      =1  #define	IN4BUF_USBVECT	(14 << 2)
 200      =1  #define	OUT4BUF_USBVECT	(15 << 2)
 201      =1  #define	IN5BUF_USBVECT	(16 << 2)
 202      =1  #define	OUT5BUF_USBVECT	(17 << 2)
 203      =1  #define	IN6BUF_USBVECT	(18 << 2)
 204      =1  #define	OUT6BUF_USBVECT	(19 << 2)
 205      =1  #define	IN7BUF_USBVECT	(20 << 2)
 206      =1  #define	OUT7BUF_USBVECT	(21 << 2)
 207      =1  
 208      =1  typedef struct
 209      =1  {
 210      =1  	BYTE	length;
 211      =1  	BYTE	type;
 212      =1  }DSCR;
 213      =1  
 214      =1  typedef struct				// Device Descriptor
 215      =1  {
 216      =1  	BYTE	length;			// Descriptor length ( = sizeof(DEVICEDSCR) )
 217      =1  	BYTE	type;			// Decriptor type (Device = 1)
 218      =1  	BYTE	spec_ver_minor;	// Specification Version (BCD) minor
 219      =1  	BYTE	spec_ver_major;	// Specification Version (BCD) major
 220      =1  	BYTE	dev_class;		// Device class
 221      =1  	BYTE	sub_class;		// Device sub-class
 222      =1  	BYTE	protocol;		// Device sub-sub-class
 223      =1  	BYTE	max_packet;		// Maximum packet size
 224      =1  	WORD	vendor_id;		// Vendor ID
 225      =1  	WORD	product_id;		// Product ID
 226      =1  	WORD	version_id;		// Product version ID
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 5   

 227      =1  	BYTE	mfg_str;		// Manufacturer string index
 228      =1  	BYTE	prod_str;		// Product string index
 229      =1  	BYTE	serialnum_str;	// Serial number string index
 230      =1  	BYTE	configs;		// Numder of configurations
 231      =1  }DEVICEDSCR;
 232      =1  
 233      =1  typedef struct
 234      =1  {
 235      =1  	BYTE	length;			// Configuration length ( = sizeof(CONFIGDSCR) )
 236      =1  	BYTE	type;			// Descriptor type (Configuration = 2)
 237      =1  	WORD	config_len;		// Configuration + End Points length
 238      =1  	BYTE	interfaces;		// Number of interfaces
 239      =1  	BYTE	index;			// Configuration number
 240      =1  	BYTE	config_str;		// Configuration string
 241      =1  	BYTE	attrib;			// Attributes (b7 - buspwr, b6 - selfpwr, b5 - rwu
 242      =1  	BYTE	power;			// Power requirement (div 2 ma)
 243      =1  }CONFIGDSCR;
 244      =1  
 245      =1  typedef struct
 246      =1  {
 247      =1  	BYTE	length;			// Interface descriptor length ( - sizeof(INTRFCDSCR) )
 248      =1  	BYTE	type;			// Descriptor type (Interface = 4)
 249      =1  	BYTE	index;			// Zero-based index of this interface
 250      =1  	BYTE	alt_setting;	// Alternate setting
 251      =1  	BYTE	ep_cnt;			// Number of end points 
 252      =1  	BYTE	class;			// Interface class
 253      =1  	BYTE	sub_class;		// Interface sub class
 254      =1  	BYTE	protocol;		// Interface sub sub class
 255      =1  	BYTE	interface_str;	// Interface descriptor string index
 256      =1  }INTRFCDSCR;
 257      =1  
 258      =1  typedef struct
 259      =1  {
 260      =1  	BYTE	length;			// End point descriptor length ( = sizeof(ENDPNTDSCR) )
 261      =1  	BYTE	type;			// Descriptor type (End point = 5)
 262      =1  	BYTE	addr;			// End point address
 263      =1  	BYTE	ep_type;		// End point type
 264      =1  	BYTE	mp_L;			// Maximum packet size
 265      =1  	BYTE	mp_H;
 266      =1  	BYTE	interval;		// Interrupt polling interval
 267      =1  }ENDPNTDSCR;
 268      =1  
 269      =1  typedef struct
 270      =1  {
 271      =1  	BYTE	length;			// String descriptor length
 272      =1  	BYTE	type;			// Descriptor type
 273      =1  }STRINGDSCR;
 274      =1  
 275      =1  typedef struct
 276      =1  {
 277      =1  	BYTE	cntrl;			// End point control register
 278      =1  	BYTE	bytes;			// End point buffer byte count
 279      =1  }EPIOC;
 280      =1  
 281      =1  typedef struct 
 282      =1  {
 283      =1  	BYTE	length;
 284      =1  	BYTE	*dat;
 285      =1  	BYTE	count;
 286      =1  	BYTE	status;
 287      =1  }I2CPCKT;
 288      =1  
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 6   

 289      =1  //-----------------------------------------------------------------------------
 290      =1  // Globals
 291      =1  //-----------------------------------------------------------------------------
 292      =1  extern code BYTE	USB_AutoVector;
 293      =1  
 294      =1  extern WORD	pDeviceDscr;
 295      =1  extern WORD	pConfigDscr;
 296      =1  extern WORD	pStringDscr;
 297      =1  extern code DEVICEDSCR	DeviceDscr;
 298      =1  extern code CONFIGDSCR	ConfigDscr;
 299      =1  extern code STRINGDSCR	StringDscr;
 300      =1  extern code DSCR		UserDscr;
 301      =1  
 302      =1  extern I2CPCKT	I2CPckt;
 303      =1  
 304      =1  //-----------------------------------------------------------------------------
 305      =1  // Function Prototypes
 306      =1  //-----------------------------------------------------------------------------
 307      =1  #ifdef CHIPREV_B
           =1 extern void EZUSB_IRQ_CLEAR(void);
           =1 #endif
 310      =1  
 311      =1  extern void EZUSB_Renum(void);
 312      =1  extern void EZUSB_Discon(BOOL renum);
 313      =1  
 314      =1  extern void EZUSB_Susp(void);
 315      =1  extern void EZUSB_Resume(void);
 316      =1  
 317      =1  extern void EZUSB_Delay1ms(void);
 318      =1  extern void EZUSB_Delay(WORD ms);
 319      =1  
 320      =1  extern CONFIGDSCR xdata*	EZUSB_GetConfigDscr(BYTE ConfigIdx);
 321      =1  extern INTRFCDSCR xdata*	EZUSB_GetIntrfcDscr(BYTE ConfigIdx, BYTE IntrfcIdx, BYTE AltSetting);
 322      =1  extern STRINGDSCR xdata*	EZUSB_GetStringDscr(BYTE StrIdx);
 323      =1  extern DSCR xdata*		EZUSB_GetDscr(BYTE index, DSCR* dscr, BYTE type);
 324      =1  
 325      =1  extern void EZUSB_InitI2C(void);
 326      =1  extern BOOL EZUSB_WriteI2C_(BYTE addr, BYTE length, BYTE xdata *dat);
 327      =1  extern BOOL EZUSB_ReadI2C_(BYTE addr, BYTE length, BYTE xdata *dat);
 328      =1  extern BOOL EZUSB_WriteI2C(BYTE addr, BYTE length, BYTE xdata *dat);
 329      =1  extern BOOL EZUSB_ReadI2C(BYTE addr, BYTE length, BYTE xdata *dat);
 330      =1  extern void EZUSB_WaitForEEPROMWrite(BYTE addr);
 331      =1  
 332      =1  #endif	// EZUSB_H
  16          #include <ezregs.h>
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //	File:		ezregs.h
   3      =1  //	Contents:	EZ-USB register declarations and bit mask definitions.
   4      =1  //
   5      =1  //	Copyright (c) 1997 AnchorChips, Inc. All rights reserved
   6      =1  //-----------------------------------------------------------------------------
   7      =1  #ifndef EZREGS_H	/* Header Sentry */
   8      =1  #define EZREGS_H
   9      =1  
  10      =1  /*-----------------------------------------------------------------------------
  11      =1  	Global Variables
  12      =1  -----------------------------------------------------------------------------*/
  13      =1  // The Ez-USB registers are defined here. There used to be 3 files containing
  14      =1  // this information: ezregs.h (external refs), ezregs.c (bound reg names to an 
  15      =1  // explicit address in ezusb.lib), and ezregs.inc (included in assembly files).
  16      =1  // We now use ezregs.h for register address allocation instead of ezregs.c by  
  17      =1  // using "#define ALLOCATE_EXTERN". The file ezregs.c now just includes ezregs.h.
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 7   

  18      =1  // When using "#define ALLOCATE_EXTERN", you get: 
  19      =1  // xdata volatile BYTE OUT7BUF[64]	_at_	0x7B40;
  20      =1  // Such lines used to be in ezregs.c, but now are created from ezregs.h by using
  21      =1  // the preprocessor. The definitions in ezregs.c were redundant.
  22      =1  // Incidently, these lines will not generate any space in the resulting hex 
  23      =1  // file; they just bind the symbols to the addresses for compilation. 
  24      =1  // Since the file ezregs.c is still used in the library build, you normally
  25      =1  // just need to use #include "ezregs.h" in your files (i.e. fw.c).
  26      =1  // If you want to generate your own (non-frameworks based) C example, then you 
  27      =1  // just need to put "#define ALLOCATE_EXTERN" in your main program file; 
  28      =1  // i.e. fw.c or a stand-alone C source file. Any time you link with ezusb.lib,
  29      =1  // it will not be necessary to "#define ALLOCATE_EXTERN".
  30      =1  // Without "#define ALLOCATE_EXTERN", you just get the external reference: 
  31      =1  // extern xdata volatile BYTE OUT7BUF[64]	;//	0x7B40;
  32      =1  // This uses the concatenation operator "##" to insert a comment "//" 
  33      =1  // to cut off the end of the line, "_at_	0x7B40;", which is not wanted.
  34      =1  // If you modify the register definitions below, please regenerate the file 
  35      =1  // "ezregs.inc" which uses the same basic information, but which could not be 
  36      =1  // derived automatically from this one source file using the preprocessor.
  37      =1  
  38      =1  #ifdef ALLOCATE_EXTERN
           =1 #define EXTERN
           =1 #define _AT_ _at_
           =1 #else
  42      =1  #define EXTERN extern
  43      =1  #define _AT_ ;/ ## /
  44      =1  #endif
  45      =1  
  46      =1  /* Register Assignments 3/18/99 TPM */
  47      =1  EXTERN xdata volatile BYTE OUT7BUF[64]	_AT_	0x7B40;
  48      =1  EXTERN xdata volatile BYTE IN7BUF[64]	_AT_	0x7B80;
  49      =1  EXTERN xdata volatile BYTE OUT6BUF[64]	_AT_	0x7BC0;
  50      =1  EXTERN xdata volatile BYTE IN6BUF[64]	_AT_	0x7C00;
  51      =1  EXTERN xdata volatile BYTE OUT5BUF[64]	_AT_	0x7C40;
  52      =1  EXTERN xdata volatile BYTE IN5BUF[64]	_AT_	0x7C80;
  53      =1  EXTERN xdata volatile BYTE OUT4BUF[64]	_AT_	0x7CC0;
  54      =1  EXTERN xdata volatile BYTE IN4BUF[64]	_AT_	0x7D00;
  55      =1  EXTERN xdata volatile BYTE OUT3BUF[64]	_AT_	0x7D40;
  56      =1  EXTERN xdata volatile BYTE IN3BUF[64]	_AT_	0x7D80;
  57      =1  EXTERN xdata volatile BYTE OUT2BUF[64]	_AT_	0x7DC0;
  58      =1  EXTERN xdata volatile BYTE IN2BUF[64]	_AT_	0x7E00;
  59      =1  EXTERN xdata volatile BYTE OUT1BUF[64]	_AT_	0x7E40;
  60      =1  EXTERN xdata volatile BYTE IN1BUF[64]	_AT_	0x7E80;
  61      =1  EXTERN xdata volatile BYTE OUT0BUF[64]	_AT_	0x7EC0;
  62      =1  EXTERN xdata volatile BYTE IN0BUF[64]	_AT_	0x7F00;
  63      =1  EXTERN xdata volatile BYTE OUT8DATA	_AT_	0x7F60;
  64      =1  EXTERN xdata volatile BYTE OUT9DATA	_AT_	0x7F61;
  65      =1  EXTERN xdata volatile BYTE OUT10DATA	_AT_	0x7F62;
  66      =1  EXTERN xdata volatile BYTE OUT11DATA	_AT_	0x7F63;
  67      =1  EXTERN xdata volatile BYTE OUT12DATA	_AT_	0x7F64;
  68      =1  EXTERN xdata volatile BYTE OUT13DATA	_AT_	0x7F65;
  69      =1  EXTERN xdata volatile BYTE OUT14DATA	_AT_	0x7F66;
  70      =1  EXTERN xdata volatile BYTE OUT15DATA	_AT_	0x7F67;
  71      =1  EXTERN xdata volatile BYTE IN8DATA	_AT_	0x7F68;
  72      =1  EXTERN xdata volatile BYTE IN9DATA	_AT_	0x7F69;
  73      =1  EXTERN xdata volatile BYTE IN10DATA	_AT_	0x7F6A;
  74      =1  EXTERN xdata volatile BYTE IN11DATA	_AT_	0x7F6B;
  75      =1  EXTERN xdata volatile BYTE IN12DATA	_AT_	0x7F6C;
  76      =1  EXTERN xdata volatile BYTE IN13DATA	_AT_	0x7F6D;
  77      =1  EXTERN xdata volatile BYTE IN14DATA	_AT_	0x7F6E;
  78      =1  EXTERN xdata volatile BYTE IN15DATA	_AT_	0x7F6F;
  79      =1  EXTERN xdata volatile BYTE OUT8BCH	_AT_	0x7F70;
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 8   

  80      =1  EXTERN xdata volatile BYTE OUT8BCL	_AT_	0x7F71;
  81      =1  EXTERN xdata volatile BYTE OUT9BCH	_AT_	0x7F72;
  82      =1  EXTERN xdata volatile BYTE OUT9BCL	_AT_	0x7F73;
  83      =1  EXTERN xdata volatile BYTE OUT10BCH	_AT_	0x7F74;
  84      =1  EXTERN xdata volatile BYTE OUT10BCL	_AT_	0x7F75;
  85      =1  EXTERN xdata volatile BYTE OUT11BCH	_AT_	0x7F76;
  86      =1  EXTERN xdata volatile BYTE OUT11BCL	_AT_	0x7F77;
  87      =1  EXTERN xdata volatile BYTE OUT12BCH	_AT_	0x7F78;
  88      =1  EXTERN xdata volatile BYTE OUT12BCL	_AT_	0x7F79;
  89      =1  EXTERN xdata volatile BYTE OUT13BCH	_AT_	0x7F7A;
  90      =1  EXTERN xdata volatile BYTE OUT13BCL	_AT_	0x7F7B;
  91      =1  EXTERN xdata volatile BYTE OUT14BCH	_AT_	0x7F7C;
  92      =1  EXTERN xdata volatile BYTE OUT14BCL	_AT_	0x7F7D;
  93      =1  EXTERN xdata volatile BYTE OUT15BCH	_AT_	0x7F7E;
  94      =1  EXTERN xdata volatile BYTE OUT15BCL	_AT_	0x7F7F;
  95      =1  EXTERN xdata volatile BYTE CPUCS	_AT_	0x7F92;
  96      =1  EXTERN xdata volatile BYTE PORTACFG	_AT_	0x7F93;
  97      =1  EXTERN xdata volatile BYTE PORTBCFG	_AT_	0x7F94;
  98      =1  EXTERN xdata volatile BYTE PORTCCFG	_AT_	0x7F95;
  99      =1  EXTERN xdata volatile BYTE OUTA		_AT_	0x7F96;
 100      =1  EXTERN xdata volatile BYTE OUTB		_AT_	0x7F97;
 101      =1  EXTERN xdata volatile BYTE OUTC		_AT_	0x7F98;
 102      =1  EXTERN xdata volatile BYTE PINSA	_AT_	0x7F99;
 103      =1  EXTERN xdata volatile BYTE PINSB	_AT_	0x7F9A;
 104      =1  EXTERN xdata volatile BYTE PINSC	_AT_	0x7F9B;
 105      =1  EXTERN xdata volatile BYTE OEA		_AT_	0x7F9C;
 106      =1  EXTERN xdata volatile BYTE OEB		_AT_	0x7F9D;
 107      =1  EXTERN xdata volatile BYTE OEC		_AT_	0x7F9E;
 108      =1  EXTERN xdata volatile BYTE UART230	_AT_	0x7F9F;
 109      =1  EXTERN xdata volatile BYTE ISOERR	_AT_	0x7FA0;
 110      =1  EXTERN xdata volatile BYTE ISOCTL	_AT_	0x7FA1;
 111      =1  EXTERN xdata volatile BYTE ZBCOUT	_AT_	0x7FA2;
 112      =1  EXTERN xdata volatile BYTE ZBCIN	_AT_	0x7FA3;
 113      =1  EXTERN xdata volatile BYTE I2CS		_AT_	0x7FA5;
 114      =1  EXTERN xdata volatile BYTE I2DAT	_AT_	0x7FA6;
 115      =1  EXTERN xdata volatile BYTE IVEC		_AT_	0x7FA8;
 116      =1  EXTERN xdata volatile BYTE IN07IRQ	_AT_	0x7FA9;
 117      =1  EXTERN xdata volatile BYTE OUT07IRQ	_AT_	0x7FAA;
 118      =1  EXTERN xdata volatile BYTE USBIRQ	_AT_	0x7FAB;
 119      =1  EXTERN xdata volatile BYTE IN07IEN	_AT_	0x7FAC;
 120      =1  EXTERN xdata volatile BYTE OUT07IEN	_AT_	0x7FAD;
 121      =1  EXTERN xdata volatile BYTE USBIEN	_AT_	0x7FAE;
 122      =1  EXTERN xdata volatile BYTE USBBAV	_AT_	0x7FAF;
 123      =1  EXTERN xdata volatile WORD BPADDR	_AT_	0x7FB2;
 124      =1  //volatile EXTERN xdata BYTE BPADDRL	_AT_	0x7FB3;
 125      =1  EXTERN xdata volatile EPIOC EPIO[16]	_AT_	0x7FB4;
 126      =1  EXTERN xdata volatile BYTE SUDPTRH	_AT_	0x7FD4;
 127      =1  EXTERN xdata volatile BYTE SUDPTRL	_AT_	0x7FD5;
 128      =1  EXTERN xdata volatile BYTE USBCS	_AT_	0x7FD6;
 129      =1  EXTERN xdata volatile BYTE TOGCTL	_AT_	0x7FD7;
 130      =1  EXTERN xdata volatile BYTE USBFRAMEL	_AT_	0x7FD8;
 131      =1  EXTERN xdata volatile BYTE USBFRAMEH	_AT_	0x7FD9;
 132      =1  EXTERN xdata volatile BYTE FNADDR	_AT_	0x7FDB;
 133      =1  EXTERN xdata volatile BYTE USBPAIR	_AT_	0x7FDD;
 134      =1  EXTERN xdata volatile BYTE IN07VAL	_AT_	0x7FDE;
 135      =1  EXTERN xdata volatile BYTE OUT07VAL	_AT_	0x7FDF;
 136      =1  EXTERN xdata volatile BYTE INISOVAL	_AT_	0x7FE0;
 137      =1  EXTERN xdata volatile BYTE OUTISOVAL	_AT_	0x7FE1;
 138      =1  EXTERN xdata volatile BYTE FASTXFR	_AT_	0x7FE2;
 139      =1  EXTERN xdata volatile BYTE AUTOPTRH	_AT_	0x7FE3;
 140      =1  EXTERN xdata volatile BYTE AUTOPTRL	_AT_	0x7FE4;
 141      =1  EXTERN xdata volatile BYTE AUTODATA	_AT_	0x7FE5;
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 9   

 142      =1  EXTERN xdata volatile BYTE SETUPDAT[8]	_AT_	0x7FE8;
 143      =1  EXTERN xdata volatile BYTE OUT8ADDR	_AT_	0x7FF0;
 144      =1  EXTERN xdata volatile BYTE OUT9ADDR	_AT_	0x7FF1;
 145      =1  EXTERN xdata volatile BYTE OUT10ADDR	_AT_	0x7FF2;
 146      =1  EXTERN xdata volatile BYTE OUT11ADDR	_AT_	0x7FF3;
 147      =1  EXTERN xdata volatile BYTE OUT12ADDR	_AT_	0x7FF4;
 148      =1  EXTERN xdata volatile BYTE OUT13ADDR	_AT_	0x7FF5;
 149      =1  EXTERN xdata volatile BYTE OUT14ADDR	_AT_	0x7FF6;
 150      =1  EXTERN xdata volatile BYTE OUT15ADDR	_AT_	0x7FF7;
 151      =1  EXTERN xdata volatile BYTE IN8ADDR	_AT_	0x7FF8;
 152      =1  EXTERN xdata volatile BYTE IN9ADDR	_AT_	0x7FF9;
 153      =1  EXTERN xdata volatile BYTE IN10ADDR	_AT_	0x7FFA;
 154      =1  EXTERN xdata volatile BYTE IN11ADDR	_AT_	0x7FFB;
 155      =1  EXTERN xdata volatile BYTE IN12ADDR	_AT_	0x7FFC;
 156      =1  EXTERN xdata volatile BYTE IN13ADDR	_AT_	0x7FFD;
 157      =1  EXTERN xdata volatile BYTE IN14ADDR	_AT_	0x7FFE;
 158      =1  EXTERN xdata volatile BYTE IN15ADDR	_AT_	0x7FFF;
 159      =1  
 160      =1  #undef EXTERN
 161      =1  #undef _AT_
 162      =1  
 163      =1  /*-----------------------------------------------------------------------------
 164      =1  	Special Function Registers (SFRs)
 165      =1  	The byte registers and bits defined in the following list are based
 166      =1  	on the Synopsis definition of the 8051 Special Function Registers for EZ-USB. 
 167      =1      If you modify the register definitions below, please regenerate the file 
 168      =1      "ezregs.inc" which includes the same basic information for assembly inclusion.
 169      =1  -----------------------------------------------------------------------------*/
 170      =1  
 171      =1  sfr SP      = 0x81;
 172      =1  sfr DPL     = 0x82;
 173      =1  sfr DPH     = 0x83;
 174      =1  sfr DPL1    = 0x84;
 175      =1  sfr DPH1    = 0x85;
 176      =1  sfr DPS     = 0x86;
 177      =1  			/*  DPS  */
 178      =1  			sbit SEL   = 0x86+0;
 179      =1  sfr PCON    = 0x87;	/*  PCON  */
 180      =1  			//sbit IDLE   = 0x87+0;
 181      =1  			//sbit STOP   = 0x87+1;
 182      =1  			//sbit GF0    = 0x87+2;
 183      =1  			//sbit GF1    = 0x87+3;
 184      =1  			//sbit SMOD0  = 0x87+7;
 185      =1  sfr TCON    = 0x88;
 186      =1  			/*  TCON  */
 187      =1  			sbit IT0    = 0x88+0;
 188      =1  			sbit IE0    = 0x88+1;
 189      =1  			sbit IT1    = 0x88+2;
 190      =1  			sbit IE1    = 0x88+3;
 191      =1  			sbit TR0    = 0x88+4;
 192      =1  			sbit TF0    = 0x88+5;
 193      =1  			sbit TR1    = 0x88+6;
 194      =1  			sbit TF1    = 0x88+7;
 195      =1  sfr TMOD    = 0x89;
 196      =1  			/*  TMOD  */
 197      =1  			//sbit M00    = 0x89+0;
 198      =1  			//sbit M10    = 0x89+1;
 199      =1  			//sbit CT0    = 0x89+2;
 200      =1  			//sbit GATE0  = 0x89+3;
 201      =1  			//sbit M01    = 0x89+4;
 202      =1  			//sbit M11    = 0x89+5;
 203      =1  			//sbit CT1    = 0x89+6;
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 10  

 204      =1  			//sbit GATE1  = 0x89+7;
 205      =1  sfr TL0     = 0x8A;
 206      =1  sfr TL1     = 0x8B;
 207      =1  sfr TH0     = 0x8C;
 208      =1  sfr TH1     = 0x8D;
 209      =1  sfr CKCON   = 0x8E;
 210      =1  			/*  CKCON  */
 211      =1  			//sbit MD0    = 0x89+0;
 212      =1  			//sbit MD1    = 0x89+1;
 213      =1  			//sbit MD2    = 0x89+2;
 214      =1  			//sbit T0M    = 0x89+3;
 215      =1  			//sbit T1M    = 0x89+4;
 216      =1  			//sbit T2M    = 0x89+5;
 217      =1  sfr SPC_FNC = 0x8F; // Was WRS in Reg320
 218      =1  			/*  CKCON  */
 219      =1  			//sbit WRS    = 0x8F+0;
 220      =1  sfr EXIF    = 0x91; // EXIF Bit Values differ from Reg320
 221      =1  			/*  EXIF  */
 222      =1  			//sbit USBINT = 0x91+4;
 223      =1  			//sbit I2CINT = 0x91+5;
 224      =1  			//sbit IE4    = 0x91+6;
 225      =1  			//sbit IE5    = 0x91+7;
 226      =1  sfr MPAGE  = 0x92;
 227      =1  sfr SCON0  = 0x98;
 228      =1  			/*  SCON0  */
 229      =1  			sbit RI    = 0x98+0;
 230      =1  			sbit TI    = 0x98+1;
 231      =1  			sbit RB8   = 0x98+2;
 232      =1  			sbit TB8   = 0x98+3;
 233      =1  			sbit REN   = 0x98+4;
 234      =1  			sbit SM2   = 0x98+5;
 235      =1  			sbit SM1   = 0x98+6;
 236      =1  			sbit SM0   = 0x98+7;
 237      =1  sfr SBUF0  = 0x99;
 238      =1  sfr IE     = 0xA8;
 239      =1  			/*  IE  */
 240      =1  			sbit EX0   = 0xA8+0;
 241      =1  			sbit ET0   = 0xA8+1;
 242      =1  			sbit EX1   = 0xA8+2;
 243      =1  			sbit ET1   = 0xA8+3;
 244      =1  			sbit ES0   = 0xA8+4;
 245      =1  			sbit ET2   = 0xA8+5;
 246      =1  			sbit ES1   = 0xA8+6;
 247      =1  			sbit EA    = 0xA8+7;
 248      =1  sfr IP     = 0xB8;
 249      =1  			/*  IP  */
 250      =1  			sbit PX0   = 0xB8+0;
 251      =1  			sbit PT0   = 0xB8+1;
 252      =1  			sbit PX1   = 0xB8+2;
 253      =1  			sbit PT1   = 0xB8+3;
 254      =1  			sbit PS0   = 0xB8+4;
 255      =1  			sbit PT2   = 0xB8+5;
 256      =1  			sbit PS1   = 0xB8+6;
 257      =1  sfr SCON1  = 0xC0;
 258      =1  			/*  SCON1  */
 259      =1  			sbit RI1   = 0xC0+0;
 260      =1  			sbit TI1   = 0xC0+1;
 261      =1  			sbit RB81  = 0xC0+2;
 262      =1  			sbit TB81  = 0xC0+3;
 263      =1  			sbit REN1  = 0xC0+4;
 264      =1  			sbit SM21  = 0xC0+5;
 265      =1  			sbit SM11  = 0xC0+6;
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 11  

 266      =1  			sbit SM01  = 0xC0+7;
 267      =1  sfr SBUF1  = 0xC1;
 268      =1  sfr T2CON  = 0xC8;
 269      =1  			/*  T2CON  */
 270      =1  			sbit CP_RL2 = 0xC8+0;
 271      =1  			sbit C_T2  = 0xC8+1;
 272      =1  			sbit TR2   = 0xC8+2;
 273      =1  			sbit EXEN2 = 0xC8+3;
 274      =1  			sbit TCLK  = 0xC8+4;
 275      =1  			sbit RCLK  = 0xC8+5;
 276      =1  			sbit EXF2  = 0xC8+6;
 277      =1  			sbit TF2   = 0xC8+7;
 278      =1  sfr RCAP2L = 0xCA;
 279      =1  sfr RCAP2H = 0xCB;
 280      =1  sfr TL2    = 0xCC;
 281      =1  sfr TH2    = 0xCD;
 282      =1  sfr PSW    = 0xD0;
 283      =1  			/*  PSW  */
 284      =1  			sbit P     = 0xD0+0;
 285      =1  			sbit FL    = 0xD0+1;
 286      =1  			sbit OV    = 0xD0+2;
 287      =1  			sbit RS0   = 0xD0+3;
 288      =1  			sbit RS1   = 0xD0+4;
 289      =1  			sbit F0    = 0xD0+5;
 290      =1  			sbit AC    = 0xD0+6;
 291      =1  			sbit CY    = 0xD0+7;
 292      =1  sfr EICON  = 0xD8; // Was WDCON in DS80C320; Bit Values differ from Reg320
 293      =1  			/*  EICON  */
 294      =1  			sbit INT6  = 0xD8+3;
 295      =1  			sbit RESI  = 0xD8+4;
 296      =1  			sbit ERESI = 0xD8+5;
 297      =1  			sbit SMOD1 = 0xD8+7;
 298      =1  sfr ACC    = 0xE0;
 299      =1  sfr EIE    = 0xE8; // EIE Bit Values differ from Reg320
 300      =1                          /*  EIE  */
 301      =1  			sbit EUSB    = 0xE8+0;
 302      =1  			sbit EI2C    = 0xE8+1;
 303      =1  			sbit EIEX4   = 0xE8+2;
 304      =1  			sbit EIEX5   = 0xE8+3;
 305      =1  			sbit EIEX6   = 0xE8+4;
 306      =1  sfr B      = 0xF0;
 307      =1  sfr EIP    = 0xF8; // EIP Bit Values differ from Reg320
 308      =1                          /*  EIP  */
 309      =1  			sbit PUSB    = 0xF8+0;
 310      =1  			sbit PI2C    = 0xF8+1;
 311      =1  			sbit EIPX4   = 0xF8+2;
 312      =1  			sbit EIPX5   = 0xF8+3;
 313      =1  			sbit EIPX6   = 0xF8+4;
 314      =1  
 315      =1  /*-----------------------------------------------------------------------------
 316      =1  	Bit Masks
 317      =1  -----------------------------------------------------------------------------*/
 318      =1  
 319      =1  /* CPU Control & Status Register */
 320      =1  #define bmCHIPREV		(bmBIT7 | bmBIT6 | bmBIT5 | bmBIT4)
 321      =1  #define bmCLK24OE		bmBIT1
 322      =1  #define bm8052RES		bmBIT0
 323      =1  /* Port Configuration Registers */
 324      =1  /* Port A */
 325      =1  #define bmRXD1OUT		bmBIT7
 326      =1  #define bmRXD0OUT		bmBIT6
 327      =1  #define bmFRD			bmBIT5
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 12  

 328      =1  #define bmFWR			bmBIT4
 329      =1  #define bmCS			bmBIT3
 330      =1  #define bmOE			bmBIT2
 331      =1  #define bmT1OUT			bmBIT1
 332      =1  #define bmT0OUT			bmBIT0
 333      =1  /* Port B */
 334      =1  #define bmT2OUT			bmBIT7
 335      =1  #define bmINT6			bmBIT6
 336      =1  #define bmINT5			bmBIT5
 337      =1  #define bmINT4			bmBIT4
 338      =1  #define bmTXD1			bmBIT3
 339      =1  #define bmRXD1			bmBIT2
 340      =1  #define bmT2EX			bmBIT1
 341      =1  #define bmT2			bmBIT0
 342      =1  /* Port C */
 343      =1  #define bmRD			bmBIT7
 344      =1  #define bmWR			bmBIT6
 345      =1  #define bmT1			bmBIT5
 346      =1  #define bmT0			bmBIT4
 347      =1  #define bmINT1			bmBIT3
 348      =1  #define bmINT0			bmBIT2
 349      =1  #define bmTXD0			bmBIT1
 350      =1  #define bmRXD0			bmBIT0
 351      =1  /* Isochronous Status & End Point Valid Registers */
 352      =1  #define bmEP15			bmBIT7
 353      =1  #define bmEP14			bmBIT6
 354      =1  #define bmEP13			bmBIT5
 355      =1  #define bmEP12			bmBIT4
 356      =1  #define bmEP11			bmBIT3
 357      =1  #define bmEP10			bmBIT2
 358      =1  #define bmEP9			bmBIT1
 359      =1  #define bmEP8			bmBIT0
 360      =1  /* I2C Control & Status Register */
 361      =1  #define bmSTART			bmBIT7
 362      =1  #define bmSTOP			bmBIT6
 363      =1  #define bmLASTRD		bmBIT5
 364      =1  #define bmID			(bmBIT4 | bmBIT3)
 365      =1  #define bmBERR			bmBIT2
 366      =1  #define bmACK			bmBIT1
 367      =1  #define bmDONE			bmBIT0
 368      =1  /* Interrupt Vector Register */
 369      =1  #define bmIV4			bmBIT6
 370      =1  #define bmIV3			bmBIT5
 371      =1  #define bmIV2			bmBIT4
 372      =1  #define bmIV1			bmBIT3
 373      =1  #define bmIV0			bmBIT2
 374      =1  /* End point Interrupt Request, End Point Interrupt Enable */
 375      =1  /* And End Point Valid Registers */
 376      =1  #define bmEP7			bmBIT7
 377      =1  #define bmEP6			bmBIT6
 378      =1  #define bmEP5			bmBIT5
 379      =1  #define bmEP4			bmBIT4
 380      =1  #define bmEP3			bmBIT3
 381      =1  #define bmEP2			bmBIT2
 382      =1  #define bmEP1			bmBIT1
 383      =1  #define bmEP0			bmBIT0
 384      =1  /* Global Interrupt Request & Enable Registers */
 385      =1  #define bmIBN        bmBIT5
 386      =1  #define bmURES			bmBIT4
 387      =1  #define bmSUSP			bmBIT3
 388      =1  #define bmSUTOK			bmBIT2
 389      =1  #define bmSOF			bmBIT1
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 13  

 390      =1  #define bmSUDAV			bmBIT0
 391      =1  /* Global Control */
 392      =1  #define bmBREAK			bmBIT3
 393      =1  #define bmBPPULSE		bmBIT2
 394      =1  #define bmBPEN			bmBIT1
 395      =1  #define bmAVEN			bmBIT0
 396      =1  /* USB Control & Status Register */
 397      =1  #define bmRWAKEUP		bmBIT7
 398      =1  #define bmDISCON		bmBIT3
 399      =1  #define bmDISCOE		bmBIT2
 400      =1  #define bmRENUM			bmBIT1
 401      =1  #define bmSIGRESUME		bmBIT0
 402      =1  /* End Point 0 Control & Status Register */
 403      =1  #define bmOUT			bmBIT3
 404      =1  #define bmIN			bmBIT2
 405      =1  #define bmHS			bmBIT1
 406      =1  #define bmHSSTALL		bmBIT0
 407      =1  /* End Point Control & Status Registers */
 408      =1  #define bmEPSTALL		bmBIT0
 409      =1  #define bmEPBUSY		bmBIT1
 410      =1  /* Fast Transfer Register */
 411      =1  #define bmFISO			bmBIT7
 412      =1  #define bmFBLK			bmBIT6
 413      =1  #define bmRPOL			bmBIT5
 414      =1  #define bmRMOD1			bmBIT4
 415      =1  #define bmRMOD0			bmBIT3
 416      =1  #define bmWPOL			bmBIT2
 417      =1  #define bmWMOD1			bmBIT1
 418      =1  #define bmWMOD0			bmBIT0
 419      =1  /* Endpoint Pairing Register */
 420      =1  #define bmISOSEND0		bmBIT7
 421      =1  #define bmPR6OUT		bmBIT5
 422      =1  #define bmPR4OUT		bmBIT4
 423      =1  #define bmPR2OUT		bmBIT3
 424      =1  #define bmPR6IN			bmBIT2
 425      =1  #define bmPR4IN			bmBIT1
 426      =1  #define bmPR2IN			bmBIT0
 427      =1  /* End point control offsets */
 428      =1  enum
 429      =1  {
 430      =1  	IN0BUF_ID = 0,
 431      =1  	IN1BUF_ID,
 432      =1  	IN2BUF_ID,
 433      =1  	IN3BUF_ID,
 434      =1  	IN4BUF_ID,
 435      =1  	IN5BUF_ID,
 436      =1  	IN6BUF_ID,
 437      =1  	IN7BUF_ID,
 438      =1  	OUT0BUF_ID,
 439      =1  	OUT1BUF_ID,
 440      =1  	OUT2BUF_ID,
 441      =1  	OUT3BUF_ID,
 442      =1  	OUT4BUF_ID,
 443      =1  	OUT5BUF_ID,
 444      =1  	OUT6BUF_ID,
 445      =1  	OUT7BUF_ID
 446      =1  };
 447      =1  
 448      =1  #define EP0CS	EPIO[0].cntrl
 449      =1  #define IN0BC	EPIO[0].bytes
 450      =1  #define IN1CS	EPIO[1].cntrl
 451      =1  #define IN1BC	EPIO[1].bytes
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 14  

 452      =1  #define IN2CS	EPIO[2].cntrl
 453      =1  #define IN2BC	EPIO[2].bytes
 454      =1  #define IN3CS	EPIO[3].cntrl
 455      =1  #define IN3BC	EPIO[3].bytes
 456      =1  #define IN4CS	EPIO[4].cntrl
 457      =1  #define IN4BC	EPIO[4].bytes
 458      =1  #define IN5CS	EPIO[5].cntrl
 459      =1  #define IN5BC	EPIO[5].bytes
 460      =1  #define IN6CS	EPIO[6].cntrl
 461      =1  #define IN6BC	EPIO[6].bytes
 462      =1  #define IN7CS	EPIO[7].cntrl
 463      =1  #define IN7BC	EPIO[7].bytes
 464      =1  #define OUT0CS	EPIO[8].cntrl
 465      =1  #define OUT0BC	EPIO[8].bytes
 466      =1  #define OUT1CS	EPIO[9].cntrl
 467      =1  #define OUT1BC	EPIO[9].bytes
 468      =1  #define OUT2CS	EPIO[10].cntrl
 469      =1  #define OUT2BC	EPIO[10].bytes
 470      =1  #define OUT3CS	EPIO[11].cntrl
 471      =1  #define OUT3BC	EPIO[11].bytes
 472      =1  #define OUT4CS	EPIO[12].cntrl
 473      =1  #define OUT4BC	EPIO[12].bytes
 474      =1  #define OUT5CS	EPIO[13].cntrl
 475      =1  #define OUT5BC	EPIO[13].bytes
 476      =1  #define OUT6CS	EPIO[14].cntrl
 477      =1  #define OUT6BC	EPIO[14].bytes
 478      =1  #define OUT7CS	EPIO[15].cntrl
 479      =1  #define OUT7BC	EPIO[15].bytes
 480      =1  
 481      =1  /*-----------------------------------------------------------------------------
 482      =1  	Macros
 483      =1  -----------------------------------------------------------------------------*/
 484      =1  /* Convert End point ID (d0000eee) to EPIO offset */
 485      =1  #define EPID(id)		(((~id & 0x80) >> 4) + (id & 0x07))
 486      =1  
 487      =1  
 488      =1  #endif	/* EZREGS_H */
  17          
  18          #define CSHIGH 1
  19          #define CSLOW 0xFE
  20          #define CLKLOW 0xFD
  21          #define INLOW 0xFB
  22          #define READ_CMD 3
  23          #define WRITE_CMD 2
  24          #define WRITE_ENABLE 6
  25          #define WRITE_DISABLE 4
  26          #define READ_STATUS 5
  27          #define WRITE_STATUS 1
  28          
  29          /////////////////////////////////////// Prototypes
  30          
  31          void write_25LC320 (int a, BYTE d);
  32          BYTE read_25LC320 (int a);
  33          void enable_25LC320 (void);
  34          BYTE status_25LC320 (void);
  35          void spiwritebyte (BYTE d);	//Assembly routine
  36          BYTE spireadbyte (void);	//Assembly routine
  37          
  38          main()
  39          {
  40   1      	BYTE d;
  41   1      	int a;
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 15  

  42   1      	BYTE t,x;
  43   1      
  44   1      	PORTCCFG &= 0xF0;//Turn off special functions
  45   1      	OEC |= 0x07;//C0 = CS*, C1 = CLK, C2 = OUT from EZ, C3 = IN to EZ
  46   1      	OEC &= 0xF7;
  47   1      	OUTC |= CSHIGH;//Turn CS* high
  48   1      	CKCON &= 0xF8;//Set stretch 0
  49   1      
  50   1      	while(TRUE)
  51   1      	{
  52   2      		enable_25LC320();//Enable write
  53   2      		write_25LC320 (a,d);//Write byte
  54   2      		while (status_25LC320() & 1);//Wait until done
  55   2      		t = read_25LC320 (a);//Try to read back
  56   2      		if (t != d)
  57   2      			x=0; //Test for read back, set breakpoint here
  58   2      		a++;
  59   2      		d++;
  60   2      	}
  61   1      }
  62          
  63          void write_25LC320 (int a, BYTE d)
  64          {
  65   1      	OUTC &= INLOW & CLKLOW;//Make sure signals are low
  66   1      	OUTC &= CSLOW;//Turn cs low
  67   1      	spiwritebyte (WRITE_CMD);
  68   1      	spiwritebyte (a >> 8);
  69   1      	spiwritebyte (a);
  70   1      	spiwritebyte (d);
  71   1      	OUTC |= CSHIGH;//Turn cs high
  72   1      }
  73          
  74          BYTE read_25LC320 (int a)
  75          {
  76   1      	BYTE d;
  77   1      
  78   1      	OUTC &= INLOW & CLKLOW;//Make sure signals are low
  79   1      	OUTC &= CSLOW;//Turn cs low
  80   1      	spiwritebyte (READ_CMD);
  81   1      	spiwritebyte (a >> 8);
  82   1      	spiwritebyte (a);
  83   1      	d = spireadbyte();
  84   1      	OUTC |= CSHIGH;//Turn cs high
  85   1      	return (d);
  86   1      }
  87          
  88          void enable_25LC320 (void)
  89          {
  90   1      	OUTC &= INLOW & CLKLOW;//Make sure signals are low
  91   1      	OUTC &= CSLOW;//Turn cs low
  92   1      	spiwritebyte (WRITE_ENABLE);
  93   1      	OUTC |= CSHIGH;//Turn cs high
  94   1      }
  95          
  96          BYTE status_25LC320 (void)
  97          {
  98   1      	BYTE d;
  99   1      
 100   1      	OUTC &= INLOW & CLKLOW;//Make sure signals are low
 101   1      	OUTC &= CSLOW;//Turn cs low
 102   1      	spiwritebyte (READ_STATUS);
 103   1      	d = spireadbyte();
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 16  

 104   1      	OUTC |= CSHIGH;//Turn cs high
 105   1      	return (d);
 106   1      }
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 17  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION main (BEGIN)
                                           ; SOURCE LINE # 38
                                           ; SOURCE LINE # 39
                                           ; SOURCE LINE # 44
0000 900000      E     MOV     DPTR,#PORTCCFG
0003 E0                MOVX    A,@DPTR
0004 54F0              ANL     A,#0F0H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 45
0007 900000      E     MOV     DPTR,#OEC
000A E0                MOVX    A,@DPTR
000B 4407              ORL     A,#07H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 46
000E E0                MOVX    A,@DPTR
000F 54F7              ANL     A,#0F7H
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 47
0012 900000      E     MOV     DPTR,#OUTC
0015 E0                MOVX    A,@DPTR
0016 4401              ORL     A,#01H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 48
0019 538EF8            ANL     CKCON,#0F8H
001C         ?C0001:
                                           ; SOURCE LINE # 50
                                           ; SOURCE LINE # 51
                                           ; SOURCE LINE # 52
001C 120000      R     LCALL   enable_25LC320
                                           ; SOURCE LINE # 53
001F AD00        R     MOV     R5,d
0021 AF00        R     MOV     R7,a+01H
0023 AE00        R     MOV     R6,a
0025 120000      R     LCALL   _write_25LC320
0028         ?C0003:
                                           ; SOURCE LINE # 54
0028 120000      R     LCALL   status_25LC320
002B EF                MOV     A,R7
002C 20E0F9            JB      ACC.0,?C0003
002F         ?C0004:
                                           ; SOURCE LINE # 55
002F AF00        R     MOV     R7,a+01H
0031 AE00        R     MOV     R6,a
0033 120000      R     LCALL   _read_25LC320
;---- Variable 't' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 56
0036 EF                MOV     A,R7
0037 6500        R     XRL     A,d
0039 6003              JZ      ?C0005
                                           ; SOURCE LINE # 57
003B E4                CLR     A
003C F500        R     MOV     x,A
003E         ?C0005:
                                           ; SOURCE LINE # 58
003E 0500        R     INC     a+01H
0040 E500        R     MOV     A,a+01H
0042 7002              JNZ     ?C0011
0044 0500        R     INC     a
0046         ?C0011:
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 18  

                                           ; SOURCE LINE # 59
0046 0500        R     INC     d
                                           ; SOURCE LINE # 60
0048 80D2              SJMP    ?C0001
                                           ; SOURCE LINE # 61
             ; FUNCTION main (END)

             ; FUNCTION _write_25LC320 (BEGIN)
0000 8E00        R     MOV     a,R6
0002 8F00        R     MOV     a+01H,R7
0004 8D00        R     MOV     d,R5
                                           ; SOURCE LINE # 63
                                           ; SOURCE LINE # 64
                                           ; SOURCE LINE # 65
0006 900000      E     MOV     DPTR,#OUTC
0009 E0                MOVX    A,@DPTR
000A 54F9              ANL     A,#0F9H
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 66
000D E0                MOVX    A,@DPTR
000E 54FE              ANL     A,#0FEH
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 67
0011 7F02              MOV     R7,#02H
0013 120000      E     LCALL   _spiwritebyte
                                           ; SOURCE LINE # 68
0016 E500        R     MOV     A,a
0018 FF                MOV     R7,A
0019 33                RLC     A
001A 95E0              SUBB    A,ACC
001C 120000      E     LCALL   _spiwritebyte
                                           ; SOURCE LINE # 69
001F AF00        R     MOV     R7,a+01H
0021 120000      E     LCALL   _spiwritebyte
                                           ; SOURCE LINE # 70
0024 AF00        R     MOV     R7,d
0026 120000      E     LCALL   _spiwritebyte
                                           ; SOURCE LINE # 71
0029 900000      E     MOV     DPTR,#OUTC
002C E0                MOVX    A,@DPTR
002D 4401              ORL     A,#01H
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 72
0030 22                RET     
             ; FUNCTION _write_25LC320 (END)

             ; FUNCTION _read_25LC320 (BEGIN)
0000 8E00        R     MOV     a,R6
0002 8F00        R     MOV     a+01H,R7
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 75
                                           ; SOURCE LINE # 78
0004 900000      E     MOV     DPTR,#OUTC
0007 E0                MOVX    A,@DPTR
0008 54F9              ANL     A,#0F9H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 79
000B E0                MOVX    A,@DPTR
000C 54FE              ANL     A,#0FEH
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 80
000F 7F03              MOV     R7,#03H
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 19  

0011 120000      E     LCALL   _spiwritebyte
                                           ; SOURCE LINE # 81
0014 E500        R     MOV     A,a
0016 FF                MOV     R7,A
0017 33                RLC     A
0018 95E0              SUBB    A,ACC
001A 120000      E     LCALL   _spiwritebyte
                                           ; SOURCE LINE # 82
001D AF00        R     MOV     R7,a+01H
001F 120000      E     LCALL   _spiwritebyte
                                           ; SOURCE LINE # 83
0022 120000      E     LCALL   spireadbyte
;---- Variable 'd' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 84
0025 900000      E     MOV     DPTR,#OUTC
0028 E0                MOVX    A,@DPTR
0029 4401              ORL     A,#01H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 85
                                           ; SOURCE LINE # 86
002C         ?C0008:
002C 22                RET     
             ; FUNCTION _read_25LC320 (END)

             ; FUNCTION enable_25LC320 (BEGIN)
                                           ; SOURCE LINE # 88
                                           ; SOURCE LINE # 89
                                           ; SOURCE LINE # 90
0000 900000      E     MOV     DPTR,#OUTC
0003 E0                MOVX    A,@DPTR
0004 54F9              ANL     A,#0F9H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 91
0007 E0                MOVX    A,@DPTR
0008 54FE              ANL     A,#0FEH
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 92
000B 7F06              MOV     R7,#06H
000D 120000      E     LCALL   _spiwritebyte
                                           ; SOURCE LINE # 93
0010 900000      E     MOV     DPTR,#OUTC
0013 E0                MOVX    A,@DPTR
0014 4401              ORL     A,#01H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 94
0017 22                RET     
             ; FUNCTION enable_25LC320 (END)

             ; FUNCTION status_25LC320 (BEGIN)
                                           ; SOURCE LINE # 96
                                           ; SOURCE LINE # 97
                                           ; SOURCE LINE # 100
0000 900000      E     MOV     DPTR,#OUTC
0003 E0                MOVX    A,@DPTR
0004 54F9              ANL     A,#0F9H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 101
0007 E0                MOVX    A,@DPTR
0008 54FE              ANL     A,#0FEH
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 102
000B 7F05              MOV     R7,#05H
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 20  

000D 120000      E     LCALL   _spiwritebyte
                                           ; SOURCE LINE # 103
0010 120000      E     LCALL   spireadbyte
;---- Variable 'd' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 104
0013 900000      E     MOV     DPTR,#OUTC
0016 E0                MOVX    A,@DPTR
0017 4401              ORL     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 105
                                           ; SOURCE LINE # 106
001A         ?C0010:
001A 22                RET     
             ; FUNCTION status_25LC320 (END)

C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 21  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C3H  1
SM01 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C7H  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
SM11 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C6H  1
EI2C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E9H  1
AC . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D6H  1
SM21 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C5H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
STRINGDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
PI2C . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F9H  1
FL . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D1H  1
_spiwritebyte. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
IN0BUF_ID. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IN1BUF_ID. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
status_25LC320 . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  d. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
IN2BUF_ID. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
EXF2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CEH  1
IN3BUF_ID. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
REN1 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C4H  1
IN4BUF_ID. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IN5BUF_ID. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IN6BUF_ID. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IN7BUF_ID. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
CY . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D7H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
INT6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DBH  1
spireadbyte. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
OV . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D2H  1
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  d. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0000H  1
  a. . . . . . . . . . . . . . . . . .  AUTO     DATA   INT      0001H  2
  t. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  x. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0003H  1
C_T2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C9H  1
RCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CDH  1
DSCR . . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
BOOL . . . . . . . . . . . . . . . . .  TYPEDEF  DATA   BIT      -----  1
TCLK . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CCH  1
EUSB . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
RESI . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DCH  1
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
PUSB . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00F8H  1
OUTC . . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
CP_RL2 . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C8H  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
ES1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AEH  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 22  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
ET2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ADH  1
TF1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008FH  1
TF2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CFH  1
RI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C0H  1
RB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009AH  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
TI1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C1H  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
TB8. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009BH  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
P. . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D0H  1
SM0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009FH  1
SM1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009EH  1
SM2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009DH  1
PS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BCH  1
PS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BEH  1
PT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B9H  1
RS0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D3H  1
PT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BBH  1
RS1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D4H  1
PT2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BDH  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
OEC. . . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
enable_25LC320 . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
TR2. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CAH  1
PX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00B8H  1
PX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00BAH  1
PORTCCFG . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
EIEX4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EAH  1
DEVICEDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  18
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  spec_ver_minor . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  spec_ver_major . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  dev_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  max_packet . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  vendor_id. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  product_id . . . . . . . . . . . . .  MEMBER   -----  U_INT    000AH  2
  version_id . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
  mfg_str. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000EH  1
  prod_str . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000FH  1
  serialnum_str. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  configs. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0011H  1
EIEX5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EBH  1
EIEX6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
EXEN2. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00CBH  1
SEL. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0086H  1
SMOD1. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DFH  1
REN. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      009CH  1
CONFIGDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 23  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  config_len . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  interfaces . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  index. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  config_str . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  attrib . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  power. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
_read_25LC320. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  a. . . . . . . . . . . . . . . . . .  AUTO     DATA   INT      0000H  2
  d. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
EIPX4. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FAH  1
EIPX5. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FBH  1
EIPX6. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00FCH  1
CKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
EPIOC. . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  cntrl. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bytes. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
I2CPCKT. . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  dat. . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0001H  3
  count. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  status . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
OUT0BUF_ID . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
F0 . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00D5H  1
OUT1BUF_ID . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
INTRFCDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  index. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  alt_setting. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  ep_cnt . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  class. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  interface_str. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
OUT2BUF_ID . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
OUT3BUF_ID . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
OUT4BUF_ID . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
ERESI. . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00DDH  1
ENDPNTDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  ep_type. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  mp_L . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  mp_H . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  interval . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
OUT5BUF_ID . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_write_25LC320 . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  a. . . . . . . . . . . . . . . . . .  AUTO     DATA   INT      0000H  2
  d. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0002H  1
OUT6BUF_ID . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
OUT7BUF_ID . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
RB81 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00C2H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    219    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V6.01 SPI                                                                     03/09/2005 17:50:20 PAGE 24  

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
